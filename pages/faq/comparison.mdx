# Comparison with swr and react-query

## Prefetching

### xswr

```tsx
user.fetch()
```

### swr

```tsx
mutate('/api/user', fetch('/api/user').then(res => res.json()))
```

### react-query

```tsx
await queryClient.prefetchQuery(['user'], fetchUser)
```

## Optimistic updates

### xswr

```tsx
todos.update(old => [...old, todo])
```

### swr

```tsx
mutate('/api/todos', updateFn(user), { optimisticData: user, rollbackOnError: true })
```

### react-query

```tsx
useMutation(updateTodo, {
  onMutate: async newTodo => {
    await queryClient.cancelQueries(['todos'])
    const previousTodos = queryClient.getQueryData(['todos'])
    queryClient.setQueryData(['todos'], old => [...old, newTodo])
    return { previousTodos }
  },
  onError: (err, newTodo, context) => {
    queryClient.setQueryData(['todos'], context.previousTodos)
  },
  onSettled: () => {
    queryClient.invalidateQueries(['todos'])
  },
})
```

## Cancellation

### xswr

```tsx
user.aborter.abort()
```

### swr

Unsupported.

### react-query

```tsx
queryClient.cancelQueries(['todos'])
```

## Garbage collection

### xswr

Global, per-query, and per-fetch expiration time. You can use response headers like `Cache-Control` to set an expiration time.

### swr

Unsupported.

### react-query

Global and per-query expiration time. You must define an expiration time at global scope or query scope.