# Cascading parameters

If you often reuse the same parameters, you should consider passing them to a `XSWR.ParamsProvider`.

```tsx
return <XSWR.ParamsProvider
  cooldown={5000}
  timeout={5000}
  expiration={-1}
  storage={...}
  equals={...}
  serializer={...}>
  // ...
</XSWR.ParamsProvider>
```

Each provider merges its parameters with those of its parent (or CoreProvider).

```tsx
CoreProvider({ cooldown: 5000 })
├─ useHelloMix() // { cooldown: 5000 }
└┬ ParamsProvider({ cooldown: 1000 })
 └┬ useSomeMix({ cooldown: 0 }) // { cooldown: 0 }
  └┬ ParamsProvider({ expiration: 60*1000 })
   └─ useSomeOtherMix() // { cooldown: 1000, expiration: 60*1000 }
```

## Example

Here, both `useCats` and `useDogs` will get their parameters from ParamsProvider.

```tsx
function Animals() {
  return <XSWR.ParamsProvider
    cooldown={5000}>
    <Cats />
    <Dogs />
  </XSWR.ParamsProvider>
}

function getCatSchema() {
  return XSWR.single("/api/cats", fetchAsJson, { cooldown: 1000 }) // <- Overrides parent's cooldown
}

function useCatsMix() {
  const handle = XSWR.use(getCatSchema, [])
  
  XSWR.useFetch(handle)
  return handle
}

export function Cats() {
  const { data, error } = useCatsMix()

  return <>/*...*/</>
}

function useDogsSchema() {
  return XSWR.single("/api/dogs", fetchAsJson) // <-- Uses parent's cooldown
}

function useDogsMix() {
  const handle = XSWR.use(getDogsSchema, [])

  XSWR.useFetch(handle)
  return handle
}

export function Dogs() {
  const { data, error } = useDogsMix()

  return <>/*...*/</>
}
```