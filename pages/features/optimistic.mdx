# Optimistic updates

When updating a resource (e.g. via POST, PUT or DELETE), xswr can pre-display the result before the fetcher response.

If the fetcher throws an error, xswr will rollback the resource to the previous state.

### Usage

This feature is only available for single resources, using `handle.update(previous => data)`.

You have to implement the actual update by using the extra `data` parameter in your fetcher.

You can, for example, do a `POST` request when the extra `data` parameter is passed, and `GET` otherwise. 

### Example 

```tsx
async function postAsJson<T>(url: string, more: XSWR.PosterMore<T>) {
  const { data, signal } = more

  const method = data ? "POST" : "GET"
  const body = data ? JSON.stringify(data) : undefined

  const res = await fetch(url, { method, body, signal })
  if (!res.ok) throw new Error(await res.text())

  const data = await res.json() as T
  
  return { data }
}

function useMyData() {
  const handle = XSWR.useSingle<MyData>(
    "/api/hello", 
    postAsJson)
  XSWR.useFetch(handle)
  return handle
}

export function MyApp() {
  const mydata = useMyData()

  const onUpdateClick = useCallback(() => {
    mydata
      .update(() => ({ name: "John Doe" }))
      .catch(alert)
  }, [mydata.update])

  return <>
    <div>
      {JSON.stringify(mydata.data)}
    </div>
    <button onClick={onUpdateClick}>
      Update
    </button>
  </>
}
```

### Warning

`handle.update()` will throw if an error is thrown

### Implementation

```tsx
async update<D = any, E = any, K = any>(
  key: K | undefined,
  skey: string | undefined,
  poster: Poster<D, K>,
  updater: Updater<D>,
  aborter = new AbortController(),
  tparams: TimeParams = {},
) {
  if (key === undefined) return
  if (skey === undefined) return

  const {
    cooldown: dcooldown = this.core.cooldown,
    expiration: dexpiration = this.core.expiration,
    timeout: dtimeout = this.core.timeout,
  } = tparams

  const current = this.core.get<D, E>(skey)
  const updated = updater(current.data)

  const timeout = setTimeout(() => {
    aborter.abort("Timed out")
  }, dtimeout)

  try {
    const { signal } = aborter

    this.core.mutate(skey, { data: updated, time: current.time })

    const {
      data,
      cooldown = getTimeFromDelay(dcooldown),
      expiration = getTimeFromDelay(dexpiration)
    } = await poster(key, { data: updated, signal })

    return this.core.mutate<D, E>(skey, { data, cooldown, expiration })
  } catch (error: any) {
    this.core.mutate<D, E>(skey, current)
    throw error
  } finally {
    clearTimeout(timeout)
  }
}
```